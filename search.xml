<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>726. Number of Atoms 原子的数量</title>
      <link href="/2019/06/04/726.%20Number%20of%20Atoms%20%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/2019/06/04/726.%20Number%20of%20Atoms%20%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="726-Number-of-Atoms-原子的数量"><a href="#726-Number-of-Atoms-原子的数量" class="headerlink" title="726. Number of Atoms 原子的数量"></a>726. Number of Atoms 原子的数量</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a chemical formula (given as a string), return the count of each atom.</p><p>An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.</p><p>1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.</p><p>Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.</p><p>A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.</p><p>Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>Example 1:</p><pre><code>Input: formula = &quot;H2O&quot;Output: &quot;H2O&quot;Explanation: The count of elements are {&apos;H&apos;: 2, &apos;O&apos;: 1}.</code></pre><p>Example 2:</p><pre><code>Input: formula = &quot;Mg(OH)2&quot;Output: &quot;H2MgO2&quot;Explanation: The count of elements are {&apos;H&apos;: 2, &apos;Mg&apos;: 1, &apos;O&apos;: 2}.</code></pre><p>Example 3:</p><pre><code>Input: formula = &quot;K4(ON(SO3)2)2&quot;Output: &quot;K4N2O14S4&quot;Explanation: The count of elements are {&apos;K&apos;: 4, &apos;N&apos;: 2, &apos;O&apos;: 14, &apos;S&apos;: 4}.</code></pre><p>Notes:</p><ul><li>All atom names consist of lowercase letters, except for the first character which is uppercase.</li><li>he length of formula will be in the range [1, 1000].</li><li>formula will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</li></ul><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题是一道典型的递归求解题。</p><p>我们用<strong>map</strong>来存结果，然后定义两个函数<strong>countAlpha</strong>和<strong>countDigit</strong>，分别用来返回分子和分子的个数。</p><p>我们通过不停的调用<strong>countAlpha</strong>和<strong>countDigit</strong>，来获取分子和分子的个数，把结果加到<strong>map</strong>中。</p><p>当遇见 <strong>“(“</strong> 时，我们递归调用自己，然后把返回的结果加到 <strong>map</strong>中去。</p><p>在这个过程中，我们维持一个全局变量<strong>i</strong>，来表示我们正在处理<strong>formula</strong>的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res = countAtoms(formula);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : res) &#123;</span><br><span class="line">    ans += s.first;</span><br><span class="line">    <span class="keyword">if</span> (s.second &gt; <span class="number">1</span> ) </span><br><span class="line">    ans += to_string(s.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; countAtoms(<span class="built_in">string</span> formula) &#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; formula.size()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formula[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> insideres = countAtoms(formula);</span><br><span class="line">    <span class="keyword">auto</span> digits = countDigit(formula);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : insideres) &#123;</span><br><span class="line">    count[s.first] += s.second * digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (formula[i] == <span class="string">')'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str = countAlpha(formula);</span><br><span class="line">    <span class="keyword">auto</span> digits = countDigit(formula);</span><br><span class="line">    count[str] += digits;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigit</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> digits = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(formula[i]) &amp;&amp; i &lt; formula.size()) &#123;</span><br><span class="line">    digits += formula[i];</span><br><span class="line">    i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits == <span class="string">""</span> ? <span class="number">1</span> : stoi(digits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAlpha</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> atom = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; formula.size() &amp;&amp; (atom == <span class="string">""</span> || <span class="built_in">islower</span>(formula[i]))) &#123;</span><br><span class="line">    atom += formula[i];</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> atom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU Advanced DB 课程笔记#1：Disk-oriented DBMS和In-memory DBMS对比</title>
      <link href="/2019/06/04/CMU%20Advanced%20DB%20%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%20Disk-oriented%20DBMS%E5%92%8CIn-memory%20DBMS%E5%AF%B9%E6%AF%94/"/>
      <url>/2019/06/04/CMU%20Advanced%20DB%20%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01%20Disk-oriented%20DBMS%E5%92%8CIn-memory%20DBMS%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="Disk-oriented-DBMS和In-memory-DBMS对比"><a href="#Disk-oriented-DBMS和In-memory-DBMS对比" class="headerlink" title="Disk-oriented DBMS和In-memory DBMS对比"></a>Disk-oriented DBMS和In-memory DBMS对比</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; 数据库管理系统被创建之初，硬件设施是很简陋的，当时的CPU只有一核，RAM严重不足，数据库需要被存在硬盘中去，并且访问硬盘的速度极其的慢，当时数据库很大一部分都是在做将数据从硬盘和内存之间来回移动的工作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 但是现在DRAM的存储空间越来越大，许多数据库都可以直接被放进内存中去（除了数据仓库等等），所以频繁访问硬盘所造成的低性能已经不能忽视了，In-memory DBMS开始兴起。</p><h2 id="Disk-oriented-DBMS介绍"><a href="#Disk-oriented-DBMS介绍" class="headerlink" title="Disk-oriented DBMS介绍"></a>Disk-oriented DBMS介绍</h2><h3 id="读数据操作"><a href="#读数据操作" class="headerlink" title="读数据操作"></a>读数据操作</h3><p>&nbsp; &nbsp; &nbsp; &nbsp; Disk-oriented DBMS:数据库的主要存贮地方是非易失性存储器（non-volatile storage）比如磁盘或者固态硬盘。当系统需要读取数据的时候，DB总是假定数据不在内存中，而在磁盘中，DB需要从磁盘中拿数据。</p><p>###<br>&nbsp; &nbsp; &nbsp; &nbsp;数据库在磁盘中由固定大小的slotted pages组成，pages里面包含存入的数据（tuple）。当数据从磁盘中取出的时候，我们先把数据放在In-memory buffer pool中缓存起来。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;In-memory buffer pool是数据库直接操作的对象，我们对buffer pool处理过后，数据才会被写到磁盘中。buffer pool manager负责数据在磁盘和内存之间的移动。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当query需要访问一个page时，DBMS先检查看看这个page是否已经在内存中，如果不在,DBMS就把数据从磁盘中取出来，拷贝到buffer pool中。如果buffer pool满了，DBMS需要回收pages。如果回收的pages是脏的，DBMS需要把这个page写到磁盘中。当page在内存中的时候，DMBS返回指向内存中pages的指针。<br><img src="https://user-images.githubusercontent.com/20705797/58792522-ee83b900-8626-11e9-9dd8-03f4c82aa57a.png" alt="data organization "></p><p>&nbsp; &nbsp; &nbsp; &nbsp;如上图所示，假设我们做一次数据库查询，我们搜索索引来找到一个特定的数据（tuple），我们遍历索引的B+树到叶子节点，得到一个指向page id和slot number的指针。然后我们根据page id查找page table。page table 里面存的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page table： page id -&gt; frame(in buffer pool)</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp; &nbsp; &nbsp;假设page table里面没有我们需要的page id，并且page table满了，那么此时我们需要做两件事，一个是在page table中回收一个pages，然后从硬盘中把需要的数据拿到buffer pool中去，在做这个操作的时候我们需要对page table上锁，保证不出现竞争条件。同时对于回收的那条page 我们也需要上锁，保证在回收过程中没人操作它。    最后我们更新page table的数据，令page id指向新数据。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;传统的Disk-oriented DBMS有很多缺点，比如说每次DB要访问数据的时候，一定要经过buffer pool manager把数据从硬盘拿到内存中去，这个过程很慢（需要加锁防止竞争）。并且每次访问数据的时候都要经过page table把page id转化为buffer pool里面的数据。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在传统的Disk-oriented DBMS,系统假定当一个transaction访问不在内存中的数据时会随时暂停。所以在这个过程中需要加锁来保证数据库的<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)" target="_blank" rel="noopener">ACID</a>特性。这些（放在内存中的）加锁信息被存储在另外的数据结构中，用来记录哪条transaction对哪条数据加什么类型的锁。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;对于In-memory DBMS 数据库的锁和数据存储在一起，不需要去另外的数据结构中查看加锁信息。</p><h3 id="日志和恢复机制：STEAL-NO-FORCE-policy"><a href="#日志和恢复机制：STEAL-NO-FORCE-policy" class="headerlink" title="日志和恢复机制：STEAL + NO-FORCE policy."></a>日志和恢复机制：STEAL + NO-FORCE policy.</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;STEAL的意思是被没有commit的transaction修改的page可以被写入硬盘，反之NO-STEAL就是不被允许写入硬盘。FORCE的意思是当transaction被commited后，buffer pool里面的所有dirty pages都要被flush到硬盘中，反之NO-FORCE就是不用flush到硬盘中。数据库通过写前日志（WAL）来实现这个机制。<br>&nbsp; &nbsp; &nbsp; &nbsp;下图是各个policy之间效率的对比图，可以看出STEAL + NO-FORCE policy速度最快，但是database从崩溃到恢复所需要的时间也最长。</p><p><img src="https://user-images.githubusercontent.com/20705797/58792521-edeb2280-8626-11e9-91d3-8d6ec115e0b6.png" alt="bufferpool policy"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;可以从下图看到，Disk oriented DB真正有用的工作只占CPU 7%的工作时间，大部分时间都花在buffer pool还有加锁的过程中。</p><p><img src="https://user-images.githubusercontent.com/20705797/58792525-efb4e600-8626-11e9-91ae-ee3c8557115e.png" alt="measureCPU"><br>这就引出了In-memory DBMS。In-memory DBMS假定数据存储在内存中的。</p><h2 id="In-memory-DBMS介绍"><a href="#In-memory-DBMS介绍" class="headerlink" title="In-memory DBMS介绍"></a>In-memory DBMS介绍</h2><h3 id="数据组织形式"><a href="#数据组织形式" class="headerlink" title="数据组织形式"></a>数据组织形式</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;In-memory DBMS 将数据以block的形式组织起来，并把定长的数据和不定长的数据分开存储。<br><img src="https://user-images.githubusercontent.com/20705797/58792524-ef1c4f80-8626-11e9-917d-133fb2aa8547.png" alt="inmem data organization"><br>&nbsp; &nbsp; &nbsp; &nbsp;如上图所示当我们想要访问一条数据时，我们从遍历index得到数据的block id和offset，我们可以用id和offset直接找到我们想到的数据。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;In-memory database 把锁和数据存在一起，可以更快的判断数据有没有上锁。而disk-oriented databse把锁和数据分开来存。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;B+树在In-memory DB中仍然是建立索引比较不错的数据结构。与disk oriented DB不同的是，In-memory database不会将更新索引的log写入到磁盘中，而是在计算机重启后从硬盘中载入整个数据库的时候重新建立索引，而disk oriented DB在更新数据的时候会将更新索引的log写入到磁盘中，来减少数据库恢复所需要的时间。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;和disk oriented DB不同，顺序扫描比随机扫描快不了多少，并且tuple-at-a-time iterator model不适用，因为函数调用overhead太多会导致速度很慢。</p><h3 id="日志和恢复"><a href="#日志和恢复" class="headerlink" title="日志和恢复"></a>日志和恢复</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;In-memory DB也需要写前日志（WAL），但需要记录的东西少很多，比如说不需要记录redo操作和LSN。为了加快恢复速度，In-memory DB也需要不定时的对数据库进行checkpoint操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU Advanced DB course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 83. Remove Duplicates from Sorted List 删除排序链表中的重复元素</title>
      <link href="/2019/06/03/83.%20Remove%20Duplicates%20from%20Sorted%20List/"/>
      <url>/2019/06/03/83.%20Remove%20Duplicates%20from%20Sorted%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>Example 1:</p><pre><code>Input: 1-&gt;1-&gt;2Output: 1-&gt;2</code></pre><p>Example 2:</p><pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3</code></pre><h3 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h3><p>第一种解法是常规解法，考察链表操作。设两个指针<strong>prev</strong>, <strong>curr</strong>；<strong>prev</strong>指向前一个节点，<strong>curr</strong>指向当前节点。</p><p>当<strong>prev</strong>的值等于<strong>curr</strong>的值时令<strong>prev-&gt;next = curr -&gt; next</strong>，更新<strong>curr</strong>的值。</p><p>否则<strong>curr = curr -&gt; next</strong>，<strong>prev = prev -&gt; next</strong>。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* curr = head -&gt; next;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr -&gt; val == prev -&gt; val) &#123;</span><br><span class="line">                prev -&gt; next = curr -&gt; next;</span><br><span class="line">                curr = curr -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr -&gt; next;</span><br><span class="line">            prev = prev -&gt; next;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h3><p>第二种解法是递归操作，先判断递归结束条件。</p><p>然后递归求解<strong>head -&gt; next</strong>，查看返回结果的<strong>val</strong>和<strong>head</strong>是否相同。</p><p>如果相同<strong>head -&gt; next = next -&gt; next</strong>，否则<strong>head -&gt; next = next</strong>。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> next = deleteDuplicates(head -&gt; next);</span><br><span class="line">        <span class="keyword">if</span> (head -&gt; val == next -&gt; val) &#123;</span><br><span class="line">            head -&gt; next = next -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head -&gt; next = next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 82. Remove Duplicates from Sorted List II 删除排序链表中的重复元素 II</title>
      <link href="/2019/06/03/82.%20Remove%20Duplicates%20from%20Sorted%20List%20II/"/>
      <url>/2019/06/03/82.%20Remove%20Duplicates%20from%20Sorted%20List%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82. Remove Duplicates from Sorted List II"></a>Leetcode 82. Remove Duplicates from Sorted List II</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>Example 1:</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5</code></pre><p>Example 2:</p><pre><code>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3    </code></pre><h3 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h3><p>这道题和<a href="https://blog.csdn.net/qq_31027515/article/details/90742849" target="_blank" rel="noopener">Leetcode 83. Remove Duplicates from Sorted List</a>类似。</p><p>因为要删掉所有重复的点，为了方便起见我们先设定一个fakeHead，令fakeHead -&gt; next = head。</p><p>令prev指向上个节点，curr指向当前节点。</p><p>注意，当出现了重复节点的时候，我们需要令prev -&gt; next = curr -&gt; next，当不出现重复节点的时候prev = prev -&gt; next，判断的依据是prev = prev -&gt; next，也就是prev指向的下一个节点是否为当前节点。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeHead -&gt; next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* curr = fakeHead -&gt; next;</span><br><span class="line">    ListNode* prev = fakeHead;</span><br><span class="line">       <span class="keyword">while</span>(curr -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>( curr -&gt; next != <span class="literal">NULL</span> &amp;&amp; curr -&gt; val == curr -&gt; next -&gt; val)</span><br><span class="line">  curr = curr -&gt; next;</span><br><span class="line">  <span class="keyword">if</span> ( prev -&gt; next == curr ) &#123;</span><br><span class="line">  prev = prev -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  prev -&gt; next = curr -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  curr = curr -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fakeHead -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h3><p>这题也可以用递归来做，先判断递归结束条件。</p><p>当出现重复节点的时候 直接返回deleteDuplicates递归后的结果。</p><p>当不出现时，先令head -&gt; next等于deleteDuplicates递归后的结果，然后返回head。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head -&gt; next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr -&gt; next != <span class="literal">NULL</span> &amp;&amp; curr -&gt;val == curr -&gt; next -&gt; val) &#123;</span><br><span class="line">        curr = curr -&gt; next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head  == curr) &#123;</span><br><span class="line">        head -&gt; next = deleteDuplicates(curr -&gt; next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(curr -&gt; next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing工具之AFL的安装与使用</title>
      <link href="/2019/06/02/afl/"/>
      <url>/2019/06/02/afl/</url>
      
        <content type="html"><![CDATA[<h2 id="fuzzing工具之AFL的安装与使用"><a href="#fuzzing工具之AFL的安装与使用" class="headerlink" title="fuzzing工具之AFL的安装与使用"></a>fuzzing工具之AFL的安装与使用</h2><h3 id="AFL介绍："><a href="#AFL介绍：" class="headerlink" title="AFL介绍："></a>AFL介绍：</h3><p>AFL即American Fuzzy Lop是当今使用最广泛的fuzzer，这个工具在程序执行前对程序源码进行插桩（instrumentation），以便在程序执行过程中实时获取程序的执行情况。AFL用遗传算法对程序的输入进行变异，用边覆盖（edge converage）来测试fuzzing的性能。</p><p>在执行过程中，AFL向被测程序中输入input，然后获取程序的覆盖率，将覆盖率大的input保留下来进行变异，然后在下一轮测试中向被测程序中输出这些变异后的input，一直到程序的覆盖率在较长的一段时间不能继续增大为止。</p><p>通常我们跑AFL的时候需要跑几十个小时，AFL最后会将结果保存在output文件中。</p><h3 id="AFL的安装与使用"><a href="#AFL的安装与使用" class="headerlink" title="AFL的安装与使用"></a>AFL的安装与使用</h3><p>我们首先从github上下载afl</p><p><img src="https://user-images.githubusercontent.com/20705797/58773523-e8beb100-85ef-11e9-9bc2-90120afe6b72.png" alt="git">然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>来安装AFL</p><p><img src="https://user-images.githubusercontent.com/20705797/58773525-e8beb100-85ef-11e9-804b-7f5bf0a82eb4.png" alt="make"></p><h3 id="进行fuzzing"><a href="#进行fuzzing" class="headerlink" title="进行fuzzing"></a>进行fuzzing</h3><p>在安装好afl之后，我们就可以来fuzzing程序了，但是在fuzzing程序之前，我们需要对程序进行插桩。运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=&quot;afl-gcc&quot; CXX=&quot;afl-g++&quot;</span><br></pre></td></tr></table></figure><p>就可以完成对程序进行插桩。</p><p>以sam2p为例，我们可以运行下面的命令对程序进行插桩。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773527-e9574780-85ef-11e9-9060-4d692bb1df78.png" alt="sam2p"></p><p>然后我们就可以fuzzing程序了，其中 </p><p><strong>-i</strong> 选项是fuzzer的初始输入。</p><p> <strong>-o</strong> 之后跟的是程序的输出结果。</p><p>@@在运行中会被输入所替换。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773522-e8261a80-85ef-11e9-8966-243642adc8ed.png" alt="fuzz"></p><p>下图所示是fuzzing的面板。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773526-e9574780-85ef-11e9-8482-a8d6f29dac23.png" alt="panel"></p>]]></content>
      
      
      <categories>
          
          <category> fuzzing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing工具之honggfuzz的安装与使用</title>
      <link href="/2019/06/02/honggfuzz/"/>
      <url>/2019/06/02/honggfuzz/</url>
      
        <content type="html"><![CDATA[<h2 id="fuzzing工具之honggfuzz的安装与使用"><a href="#fuzzing工具之honggfuzz的安装与使用" class="headerlink" title="fuzzing工具之honggfuzz的安装与使用"></a>fuzzing工具之honggfuzz的安装与使用</h2><h3 id="honggfuzz介绍："><a href="#honggfuzz介绍：" class="headerlink" title="honggfuzz介绍："></a>honggfuzz介绍：</h3><p>honggfuzz是由谷歌开发的，和AFL（<a href="https://blog.csdn.net/qq_31027515/article/details/90672554" target="_blank" rel="noopener">点击这里查看AFL的安装与使用</a>）类似，的反馈驱动，使用遗传算法来变异的fuzzer。</p><p>honggfuzz是一个多进程和多线程的fuzzer，所以用honggfuzz进行fuzzing的速度非常快，在安全漏洞发现中的表现十分突出。</p><h3 id="honggfuzz的安装与使用"><a href="#honggfuzz的安装与使用" class="headerlink" title="honggfuzz的安装与使用"></a>honggfuzz的安装与使用</h3><p>和AFL类似，我们首先从github上下载honggfuzz。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773661-82865e00-85f0-11e9-9956-18fe085f4339.png" alt="git"><br>然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>来安装honggfuzz</p><p><img src="https://user-images.githubusercontent.com/20705797/58773663-831ef480-85f0-11e9-8c4f-5590991faacc.png" alt="make"></p><h3 id="进行fuzzing"><a href="#进行fuzzing" class="headerlink" title="进行fuzzing"></a>进行fuzzing</h3><p>在安装好honggfuzz之后，我们就可以来fuzzing程序了，但是在fuzzing程序之前，我们需要对程序进行插桩。运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=&quot;hfuzz-gcc&quot; CXX=&quot;hfuzz-g++&quot;</span><br></pre></td></tr></table></figure><p>就可以完成对程序进行插桩。</p><p>以tiff软件为例，我们可以运行下面的命令对程序进行插桩，然后运行<em>make;make install</em>命令安装tiff软件。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773659-81edc780-85f0-11e9-82b8-a6efd74b4331.png" alt="compile"></p><p>然后我们就可以fuzzing程序了。<br>其中 <strong>-f</strong> 选项是fuzzer的初始输入，tiff_seed文件夹中包含了很多tiff格式的文件。下图是fuzzing代码。<br><img src="https://user-images.githubusercontent.com/20705797/58773660-82865e00-85f0-11e9-882c-ed797dc5e545.png" alt="fuzz"><br>其中 <strong>-f</strong> 选项后面指向程序的输入文件夹。<br><strong>-w</strong> 之后跟的是程序的输出结果。</p><p><strong>-t</strong> 选项设定timeout</p><p><strong>–run-time</strong> 选项制定fuzzer运行的时间</p><p><strong>-z</strong> 表示采用插桩模式，对源码进插桩<br><strong>__FILE __</strong>: 相当于AFL中的@@, 在运行时被程序的输入文件替换。</p><p>下图所示是执行完上图脚本后的fuzzing的面板。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773664-831ef480-85f0-11e9-9c32-34ee33ebfbe1.png" alt="panel"></p>]]></content>
      
      
      <categories>
          
          <category> fuzzing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> honggfuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing工具之Angora的安装与使用</title>
      <link href="/2019/06/02/angora/"/>
      <url>/2019/06/02/angora/</url>
      
        <content type="html"><![CDATA[<h2 id="fuzzing工具之Angora的安装与使用"><a href="#fuzzing工具之Angora的安装与使用" class="headerlink" title="fuzzing工具之Angora的安装与使用"></a>fuzzing工具之Angora的安装与使用</h2><h3 id="Angora介绍："><a href="#Angora介绍：" class="headerlink" title="Angora介绍："></a>Angora介绍：</h3><p>Angora 是安全四大会中Okland会议中发表的fuzzer，Angora是基于突变的、覆盖率指导的fuzzer。目前fuzzer中一大难题是如何解决fuzzing过程中的路径约束，以提高 branch coverage。Angora在没有利用符号执行的前提下解决了这个问题。</p><p>在Angora paper中Angora表现优异，大幅超过AFL。</p><h3 id="Angora的安装与使用"><a href="#Angora的安装与使用" class="headerlink" title="Angora的安装与使用"></a>Angora的安装与使用</h3><p>第一步从github上下载Angora</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AngoraFuzzer/Angora</span><br></pre></td></tr></table></figure><p>Angora需要LLVM4.0的支持，所以我们要下载LLVM4.0，命令如下。<br><img src="https://user-images.githubusercontent.com/20705797/58773571-1efc3080-85f0-11e9-9103-ce38c815f9d7.png" alt="llvm"><br>然后我们把下面两个环境变量添加到(<code>~/.bashrc</code>, <code>~/.zshrc</code>)中去。<br><img src="https://user-images.githubusercontent.com/20705797/58773570-1e639a00-85f0-11e9-9a6d-c2bc4617246c.png" alt="line"></p><h3 id="fuzzer编译"><a href="#fuzzer编译" class="headerlink" title="fuzzer编译"></a>fuzzer编译</h3><p>运行如下命令编译fuzzer。<br><img src="https://user-images.githubusercontent.com/20705797/58773573-1efc3080-85f0-11e9-9170-399d9b3c5573.png" alt="script"></p><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>和AFL一样，系统的core dumps必须被disable。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773564-1c99d680-85f0-11e9-908c-5def76ee0dc0.png" alt="core"></p><h3 id="编译目标程序"><a href="#编译目标程序" class="headerlink" title="编译目标程序"></a>编译目标程序</h3><p>用如下命令编译有 taint tracking支持的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE_TRACK=1 make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/20705797/58773574-1f94c700-85f0-11e9-9293-49b2c991fb1f.png" alt="taint"><br>把编译后的结果放在tain目录下，并加上.taint后缀。<br><img src="https://user-images.githubusercontent.com/20705797/58773566-1d326d00-85f0-11e9-8eaf-ac785d18a7a4.png" alt="cptaint"><br>然后用如下命令编译有light instrumentation支持的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">USE_FAST=1 make -j</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/20705797/58773567-1d326d00-85f0-11e9-855f-cbe310ec3a80.png" alt="fast"><br>把编译后的结果放在fast目录下，并加上.fast后缀。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773565-1c99d680-85f0-11e9-9856-f07f9337a77a.png" alt="cpfast"></p><h3 id="进行fuzzing"><a href="#进行fuzzing" class="headerlink" title="进行fuzzing"></a>进行fuzzing</h3><p>用如下命令对程序进行fuzz。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./angora_fuzzer -i input -o output -t path/to/taint/program -- path/to/fast/program [argv]</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/20705797/58773568-1dcb0380-85f0-11e9-8eac-c039e0e1450e.png" alt="fuzz"><br>fuzzing面板如下图所示。<br><img src="https://user-images.githubusercontent.com/20705797/58773569-1dcb0380-85f0-11e9-8ced-5e6520d438f2.png" alt="fuzz5"></p>]]></content>
      
      
      <categories>
          
          <category> fuzzing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Angora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Netty进行socket编程</title>
      <link href="/2019/06/02/%E7%94%A8netty%E7%BC%96%E5%86%99clientServer/"/>
      <url>/2019/06/02/%E7%94%A8netty%E7%BC%96%E5%86%99clientServer/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用Netty进行socket编程"><a href="#如何用Netty进行socket编程" class="headerlink" title="如何用Netty进行socket编程"></a>如何用Netty进行socket编程</h1><p><a href="https://blog.csdn.net/qq_31027515/article/details/90613839" target="_blank" rel="noopener">前一篇文章</a>讲的是如何用Netty进行http服务器的编写，http是应用层协议，Netty不仅可以直接操作应用层，还可以接触最底层的socket服务，进行socket调用。</p><p>目前业界许多大数据开源项目都使用了Netty做底层传输的基础框架，如Spark等。而不是使用HTTP作为传输协议，因为http效率会很低，所以大部分都使用RPC。</p><p>用Netty进行socket编程和传统的java编程类似，我们需要编写客户端和服务器端。</p><p>本文主要介绍如何用Netty进行socket编程，以及如何用Netty编写Client Server程序。</p><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>在src/main/java文件夹中建立如下工程。<br><img src="https://user-images.githubusercontent.com/20705797/58773463-bad96c80-85ef-11e9-83b8-2e727e921101.png" alt="socketExample"><br>然后在该工程下建立6个class文件，名称如下图所示。<br><img src="https://user-images.githubusercontent.com/20705797/58773464-bad96c80-85ef-11e9-98a2-4aa48be0d49c.png" alt="项目结构"></p><h2 id="Server部分编写"><a href="#Server部分编写" class="headerlink" title="Server部分编写"></a>Server部分编写</h2><p>该部分用来编写和client通信的server端，该端接受client发送的请求，并回复client信息。</p><h3 id="Server主程序"><a href="#Server主程序" class="headerlink" title="Server主程序"></a>Server主程序</h3><p>Socket Server主程序的编写和Http Server类似（<a href="https://mp.csdn.net/mdeditor/90613839" target="_blank" rel="noopener">点击查看</a>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8889</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server初始化过程用来添加几个过滤器，这些过滤器的功能包括，格式编解码，字符串编解码，以及我们自己的处理类。</p><h3 id="Server初始化"><a href="#Server初始化" class="headerlink" title="Server初始化"></a>Server初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestSocketServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中LengthFieldBasedFrameDecoder是一个解码器。<br>LengthFieldPrepender是编码器会prepend消息的长度，把消息的长度作为二进制加如消息的头部。<br>StringDecoder 是字符串解码。</p><h3 id="Server请求处理"><a href="#Server请求处理" class="headerlink" title="Server请求处理"></a>Server请求处理</h3><p>我们用ChannelHandlerContext类中的ChannelRead0函数收到数据，做处理，然后处理完成后把结果返回给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSocketServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">": "</span> + msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">"message received."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelHandlerContext 表示上下文信息，比如说远程地址、channel对象。<br>msg是接收到的请求对象。</p><h2 id="Client部分编写"><a href="#Client部分编写" class="headerlink" title="Client部分编写"></a>Client部分编写</h2><p>客户端只需要一个事件循环组就够了，并在在处理channel的时候使用handler函数，而不是childHandler。</p><p>若在服务器端的channel使用handler，则handler针对的是BossGroup的信息，使用childHandler 针对的是workerGroup里面的NIO信息（NIO线程）。</p><h3 id="Client主程序"><a href="#Client主程序" class="headerlink" title="Client主程序"></a>Client主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(<span class="keyword">new</span> TestClientInitializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8889</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端初始化和server较类似。</p><h3 id="Client初始化"><a href="#Client初始化" class="headerlink" title="Client初始化"></a>Client初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> TestClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端消息处理和server也是异曲同工的。</p><h3 id="Client消息处理"><a href="#Client消息处理" class="headerlink" title="Client消息处理"></a>Client消息处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">": "</span> + msg);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">"Hello Server"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty：简易Http Webserver编写</title>
      <link href="/2019/06/02/netty%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AEwebserver/"/>
      <url>/2019/06/02/netty%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AEwebserver/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty：简易Http-Webserver编写"><a href="#Netty：简易Http-Webserver编写" class="headerlink" title="Netty：简易Http Webserver编写"></a>Netty：简易Http Webserver编写</h2><h3 id="Netty-介绍"><a href="#Netty-介绍" class="headerlink" title="Netty 介绍"></a>Netty 介绍</h3><p>Netty 是一个基于NIO的客户、服务器端编程框架。使用Netty可以使我们快速简单的开发网络应用。</p><p>Netty有很多功能，我们可以用Netty作为RPC框架，实现远程过程的调用；也可以编写长连接的服务器，使用websocket等功能；我们还可以把Netty当做http服务器（类似Tomcat），对http请求进行接收和响应。用Netty编写服务器时，采取的编程模型和获取请求模型不遵循serlvet规范，Netty有自己一套处理方式。</p><p>下面我们进行一段简易HttpServer的编写（作者使用Intellij IDEA进行Netty项目的开发）。</p><h3 id="创建Netty工程"><a href="#创建Netty工程" class="headerlink" title="创建Netty工程"></a>创建Netty工程</h3><p>打开IDEA，创建一个gradle项目。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773203-c2e4dc80-85ee-11e9-8e95-06965ca39eb4.png" alt="netty工程创建"></p><p>点击下一步，输入GroupID（公司域名反转）和ArtifactID（模块名）</p><p><img src="https://user-images.githubusercontent.com/20705797/58773201-c24c4600-85ee-11e9-9c95-fdd477dfc6fb.png" alt="groupid"></p><p>然后一直点下一步直到FInished。</p><p>至此我们便创建了一个工程，工程目录如下图所示：</p><p><img src="https://user-images.githubusercontent.com/20705797/58773212-c4aea000-85ee-11e9-85d9-df4aa23a65f9.png" alt="工程目录"><br>我们在src/main/java文件夹中编写应用代码,src/test中是我们编写测试文件用的，本文忽略测试文件。</p><h3 id="导入netty-jar包"><a href="#导入netty-jar包" class="headerlink" title="导入netty jar包"></a>导入netty jar包</h3><p>导入netty jar包的过程很简单，我们可以在build.gradle文件的dependencies下加入下面一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile group: &apos;io.netty&apos;, name: &apos;netty-all&apos;, version: &apos;4.1.36.Final&apos;</span><br></pre></td></tr></table></figure><p>如下图所示<br><img src="https://user-images.githubusercontent.com/20705797/58773200-c24c4600-85ee-11e9-9317-15674d51e97d.png" alt="dependencies"><br>最新引入netty的代码可以在<a href="https://mvnrepository.com/artifact/io.netty/netty-all" target="_blank" rel="noopener">maven repository</a>中通过搜索netty all关键词找到。</p><p>然后我们就可以进行HttpServer的编写了。</p><h3 id="Server编写"><a href="#Server编写" class="headerlink" title="Server编写"></a>Server编写</h3><p>右击src/main/java文件夹，new一个新的package，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773204-c2e4dc80-85ee-11e9-8e51-3a5258122317.png" alt="newpackage"><br>然后在这个package中创建一个class名为<strong>TestServer</strong><br><img src="https://user-images.githubusercontent.com/20705797/58773208-c4160980-85ee-11e9-914f-1136ac653177.png" alt="TestServer"></p><p>在TestServer class中创建<strong>main</strong>函数,在<strong>main</strong>函数里面我们创建两个<strong>NioEventLoopGroup</strong>,分别为bossGroup，workerGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>bossGroup接受连接请求并把请求交给workerGroup处理;workerGroup获取请求参数,进行业务处理，然后把结果返回客户端。</p><p>然后创建<strong>ServerBootstrap</strong> 类的实例，<strong>ServerBootstrap</strong> 是简化服务端启动的类。该类通过反射的形式创建NioServerSocketChannel。</p><p>channel相当于链接，同用户端进行网络连接、关闭和读写。</p><p>最后调用<strong>ChildHandler</strong>方法，里面传入一个对请求进行处理的类，在本例代码中我们传入我们编写的<strong>TestServerInitializer</strong>实例（请看下一节）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br></pre></td></tr></table></figure><p>然后我们把这个服务器绑定在8888端口上，就可以接受用户端的请求了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">channelFuture.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><p>完整代码如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ServerInitializer编写"><a href="#ServerInitializer编写" class="headerlink" title="ServerInitializer编写"></a>ServerInitializer编写</h3><p><img src="https://user-images.githubusercontent.com/20705797/58773210-c4160980-85ee-11e9-9805-8abe59ebbe92.png" alt="TestServerINitializer"><br>在同一个package中创建<strong>TestServerInitializer</strong>类，该类需要继承<strong>ChannelInitializer</strong>类，同时需要实现<strong>initChannel</strong>方法。</p><p>在连接被注册的时候，即<strong>ChannelInitializer</strong>被创建时会立即调用<strong>initChannel</strong>方法。</p><p>我们在该方法中创建一个pipeline。<strong>ChannelHandler</strong> 类似过滤器；<strong>ChannelPipeline</strong> 是管道，由多个channel handle共同构成。<strong>ChannelHandler</strong> 和<strong>ChannelPipeline</strong> 用于channel事件的拦截和处理。</p><p>在这个管道中我们先加入<strong>HttpServerCodec</strong>。<strong>HttpServerCodec</strong> 是一个用于对web请求进行编解码操作的Channelhandler。然后我们再加入<strong>TestHttpServerHandler</strong>（请看下一节），这个handler是一个我们自己编写用于对请求进行操作的类。</p><p>具体代码如下图所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="string">"httpServerCodec"</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        pipeline.addLast(<span class="string">"testHttpServerHandler"</span>, <span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestHttpServerHandler编写"><a href="#TestHttpServerHandler编写" class="headerlink" title="TestHttpServerHandler编写"></a>TestHttpServerHandler编写</h3><p>在同一个package中创建<strong>TestHttpServerHandler</strong>类,在该类中我们创建“Hello，World”字符串，然后当用户对服务器进行请求时，将Hello，World返回给用户。</p><p><strong>TestHttpServerHandler</strong>需要继承<strong>SimpleChannelInboundHandler</strong> 类，并实现<strong>channelRead0</strong>方法。<strong>channelread0</strong> 读取客户端发送的请求，并向客户端返回响应的代码的函数。</p><p>我们用<strong>ByteBuf</strong>构建Hello，World字符串，<strong>ByteBuf</strong> 是Netty实现的最基本的数据缓冲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf content = Unpooled.copiedBuffer(<span class="string">"Hello, World"</span>, CharsetUtil.UTF_8);</span><br></pre></td></tr></table></figure><p>然后用<strong>DefaultFullHttpResponse</strong>构建响应，该类接受的参数有：协议类型，返回状态，返回内容（即helloworld）。</p><p>然后我们对响应头进行设置，设置内容类型为text/plain，以及设置内容长度为Hello，World的长度。</p><p>最后用<strong>ctx.writeAndFlush</strong>方法把内容返回给客户端。</p><p>具体代码如下所示。<br><img src="https://user-images.githubusercontent.com/20705797/58773206-c37d7300-85ee-11e9-9ffd-e2a4aa641699.png" alt="TestHttpServerHandler"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">"Hello, World"</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain"</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行Netty服务器"><a href="#运行Netty服务器" class="headerlink" title="运行Netty服务器"></a>运行Netty服务器</h3><p>点击Run-&gt; Run “TestServer”运行刚刚编写的程序。<br><img src="https://user-images.githubusercontent.com/20705797/58773205-c37d7300-85ee-11e9-92eb-44c10a06b8fd.png" alt="runserver"></p><p>打开浏览器，输入网址localhost:8888<br>可以看到服务器返回Hello，World</p><p><img src="https://user-images.githubusercontent.com/20705797/58773213-c5473680-85ee-11e9-84b4-4cf64997d61c.png" alt="返回helloworld"></p><p>至此，我们第一个netty服务器就编写成功了！</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的httpserver执行流程分析</title>
      <link href="/2019/06/02/Netty%E7%9A%84httpserver%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/02/Netty%E7%9A%84httpserver%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty的httpserver执行流程分析"><a href="#Netty的httpserver执行流程分析" class="headerlink" title="Netty的httpserver执行流程分析"></a>Netty的httpserver执行流程分析</h2><p>在<a href="https://blog.csdn.net/qq_31027515/article/details/90613839" target="_blank" rel="noopener">上一篇文章</a>，我们用Netty进行了一个建议的HttpServer的编写，在本文，我们对该server的执行流程做简要的分析。</p><h3 id="回调函数介绍"><a href="#回调函数介绍" class="headerlink" title="回调函数介绍"></a>回调函数介绍</h3><p>我们在上一节编写的TestHttpServerHandler类是继承SimpleChannelInboundHandler类，该类是专门对客户端发送请求进行处理的类。通过观察源码，我们发现该类又继承了ChannelInboundHandlerAdapter类。<br><img src="https://user-images.githubusercontent.com/20705797/58773393-7e0d7580-85ef-11e9-98f3-2b13bdd47ec8.png" alt="channelINboundHandler"></p><p>ChannelInboundHandlerAdapter类中有很多回调函数，例如handlerAdded，channelActive，channelInactive，channelRegisteredchannelUnregistered等函数。这些函数分别是在handler被加入时，channel被注册和取消注册时以及channel被激活时由Netty框架进行调用。<br>我们在TestServerInitializer类中覆盖这五个方法，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channel active"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channel inactive"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channel registered"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channel unregistered"</span>);</span><br><span class="line">    <span class="keyword">super</span>.channelUnregistered(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"handler added"</span>);</span><br><span class="line">    <span class="keyword">super</span>.handlerAdded(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="curl命令和浏览器之间的表现差异"><a href="#curl命令和浏览器之间的表现差异" class="headerlink" title="curl命令和浏览器之间的表现差异"></a>curl命令和浏览器之间的表现差异</h3><p>然后我们用curl命令对服务器进行请求看看服务器终端中会出现什么结果：</p><p><img src="https://user-images.githubusercontent.com/20705797/58773395-7ea60c00-85ef-11e9-9187-008b8d7bd8c7.png" alt="curl"></p><p>服务器返回结果如下所示：</p><p><img src="https://user-images.githubusercontent.com/20705797/58773396-7f3ea280-85ef-11e9-9202-afbcd88fdf00.png" alt="服务器返回结果"></p><p>可以看到server的执行流程是按照如下五步进行的。</p><ol><li>handler added</li><li>channel registered</li><li>channel active</li><li>channel inactive</li><li>channel unregistered</li></ol><p>但是如果我们用浏览器（Chrome）对服务器进行请求时，却发现命令行返回结果如下图所示。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773397-7f3ea280-85ef-11e9-93f0-957180b53616.png" alt="浏览器curl"><br>在该图中，每一步都执行了两次，并且没有channel inactive和channel unregistered输出，这是为什么呢？</p><p>打开google开发者工具，点击Network，我们可以看到，浏览器不仅请求了localhost根目录，还请求了favicon.ico文件，所以一共执行了两个请求，所以每一步都执行了两次。</p><p>（注意不同浏览器请求不同，比如说Firefox中就不会请求localhost两次）</p><p><img src="https://user-images.githubusercontent.com/20705797/58773394-7ea60c00-85ef-11e9-89cd-62a30575b0ad.png" alt="chrome流量"></p><p>当我们关闭Chrome标签时，终端输出了如下信息。</p><p><img src="https://user-images.githubusercontent.com/20705797/58773398-7fd73900-85ef-11e9-80dc-901807881246.png" alt="浏览器关闭"><br>所以我们知道在浏览器打开localhost的时候请求一直都保持连接，所以不会输出channel inactive和channel unregistered。</p><p>而因为curl是网络命令工具，在curl请求完之后，请求就关闭掉了，所以会直接输出channel inactive和channel unregistered信息。</p><p>如果是spring MVC框架，在处理完请求返回给用户之后，Tomcat会保证响应的连接会自动关闭掉。但是Netty需要自己做，需要自己写代码令服务器端主动关闭连接。</p><p>需要在channelRead0函数末尾加上<em>ctx.channel().close();</em>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf content = Unpooled.copiedBuffer(<span class="string">"Hello, World"</span>, CharsetUtil.UTF_8);</span><br><span class="line">        FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">"text/plain"</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流程分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven教程</title>
      <link href="/2019/06/02/maven%E5%AE%89%E8%A3%85/"/>
      <url>/2019/06/02/maven%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven教程"><a href="#Maven教程" class="headerlink" title="Maven教程"></a>Maven教程</h2><p>Maven是一款基于JAVA平台的自动化构建工具。本节介绍Maven的安装和基础知识。</p><p>###Maven 安装</p><p>####安装JAVA并设置JAVA_HOME变量<br>在安装Maven之前首先要确保JAVA已经安装到系统中，并正确设置了JAVA_HOME变量。<br>在linux环境下，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure><p>若返回值为path_to_jdk，则说明JAVA设置正确。</p><p>####解压Maven核心程序包，并将解压路径添加到PATH环境变量中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf apache-maven-3.6.1-bin.tar.gz</span><br></pre></td></tr></table></figure><p>然后在命令行中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p>如果输出结果不为空，则表明Maven安装成功。</p><p>####创建一个Maven工程<br>运行如下代码创建一个Maven工程，其中groupdId是公司或者组织域名+项目名，artifactId是模块名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -B archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DgroupId=com.first.app -DartifactId=first-maven-app</span><br></pre></td></tr></table></figure><p>在创建成功之后，我们打开这个工程，可以看到一个名为pom.xml的文件，<br>POM.xml是项目对象模型，是Maven的核心配置文件，与构建过程中的一切设置都在这个文件中配置。该文件的内容如下图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.first.app&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;first-maven-app&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;first-maven-app&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>其中packaging是打包格式，version是工程版本，name是工程的名字。 </p><p>####输入测试代码<br>在<strong>src/main/java/com/first/app/App.java</strong>中输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.first.app;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  HelloWorld myWorld = new HelloWorld();</span><br><span class="line">  String said = myWorld.sayHelloTo(&quot;World&quot;);</span><br><span class="line">  System.out.println(said);</span><br><span class="line"> &#125;</span><br><span class="line"> public String sayHelloTo(String to) &#123;</span><br><span class="line">  return &quot;Hello &quot;+to+&quot;!&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>命令编译主程序了。</p>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1011. Capacity To Ship Packages Within D Days 在 D 天内送达包裹的能力</title>
      <link href="/2019/06/02/1011.%20Capacity%20To%20Ship%20Packages%20Within%20D%20Days/"/>
      <url>/2019/06/02/1011.%20Capacity%20To%20Ship%20Packages%20Within%20D%20Days/</url>
      
        <content type="html"><![CDATA[<h2 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a>1011. Capacity To Ship Packages Within D Days</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>A conveyor belt has packages that must be shipped from one port to another within D days.</p><p>The i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</p><p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. </code></pre><h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>这道题用二分查找法，二分查找的左边是最重包裹的重量，二分查找的右边是所有包裹的重量和。</p><p>每次做二分查找的时候，判断查找的重量（也就是船的负载）是否能让船在<strong>D</strong>天内把货物送达。</p><p>如果天数小于<strong>D</strong>，让<strong>左边=查找的重量+1</strong> 若天数大于等于<strong>D</strong>，让<strong>右边=查找的重量</strong>。</p><p>最后得到的重量就是货物的负载量。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> upperBound = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : weights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w &gt; maxWeight)</span><br><span class="line">        maxWeight = w;</span><br><span class="line">        upperBound += w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (maxWeight &lt; upperBound) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> localWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (maxWeight + upperBound) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;w : weights) &#123;</span><br><span class="line">        localWeight += w;</span><br><span class="line">        <span class="keyword">if</span> (localWeight &gt; mid) &#123;</span><br><span class="line">        days ++;</span><br><span class="line">        localWeight = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (days &gt; D) maxWeight = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (days &lt;= D) upperBound = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 946. Validate Stack Sequences 验证栈序列</title>
      <link href="/2019/06/02/946.%20Validate%20Stack%20Sequences/"/>
      <url>/2019/06/02/946.%20Validate%20Stack%20Sequences/</url>
      
        <content type="html"><![CDATA[<h2 id="946-Validate-Stack-Sequences"><a href="#946-Validate-Stack-Sequences" class="headerlink" title="946. Validate Stack Sequences"></a>946. Validate Stack Sequences</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><pre><code>Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</code></pre><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><pre><code>Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2.</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题很简单，把pushed数组里面的每个数字入栈，然后当push的值和popped里面的第一个未处理的值相等的时候，就进入循环，将popped数组里面的值从栈中移除。</p><p>最后判断popped数组里面的值是否处理完。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : pushed) &#123;</span><br><span class="line">        mystack.push(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!mystack.empty() &amp;&amp; mystack.top() == popped[i]) &#123;</span><br><span class="line">        i ++;</span><br><span class="line">        </span><br><span class="line">        mystack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mystack.empty() &amp;&amp; i == popped.size())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>871. Minimum Number of Refueling Stops</title>
      <link href="/2019/06/02/871.%20Minimum%20Number%20of%20Refueling%20Stops/"/>
      <url>/2019/06/02/871.%20Minimum%20Number%20of%20Refueling%20Stops/</url>
      
        <content type="html"><![CDATA[<h2 id="871-Minimum-Number-of-Refueling-Stops"><a href="#871-Minimum-Number-of-Refueling-Stops" class="headerlink" title="871. Minimum Number of Refueling Stops"></a>871. Minimum Number of Refueling Stops</h2><h3 id="description"><a href="#description" class="headerlink" title="description:"></a>description:</h3><p>TA car travels from a starting position to a destination which is target miles east of the starting position.</p><p>Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.</p><p>The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.</p><p>When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p><p>What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.</p><p>Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><pre><code>Input: target = 1, startFuel = 1, stations = []Output: 0Explanation: We can reach the target without refueling.</code></pre><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><pre><code>Input: target = 100, startFuel = 1, stations = [[10,100]]Output: -1Explanation: We can&apos;t reach the target (or even the first gas station).</code></pre><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><pre><code>Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]Output: 2Explanation: We start with 10 liters of fuel.We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.Then, we drive from position 10 to position 60 (expending 50 liters of fuel),and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.We made 2 refueling stops along the way, so we return 2.</code></pre><p>###Note:</p><pre><code>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^90 &lt;= stations.length &lt;= 5000 &lt; stations[0][0] &lt; stations[1][0] &lt; ... &lt; stations[stations.length-1][0] &lt; target</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题可以用最大堆的思维去理解</p><p>假设车一开始有n升油，一升油可以跑1公里，那么我们可以先让车跑n公里，看看在这n公里内有几个加油站，然后选择油最多的加油站进行加油（假设这个加油站的油量为t），然后再看（n + t）升油可以跑几公里，然后再次挑选油最多的加油站进行加油。在这个过程中统计加油次数。</p><p>在这个过程中用优先队列，里面按照油量的多少，从大到小存放可以加的油。</p><p>该题的结束条件是，当车可以跑的公里数大于终点的公里数，那么就返回加油次数。或者当没油可加，即优先队列为空时，返回 -1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue &lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stations)</span> </span>&#123;</span><br><span class="line">        <span class="comment">///stations为空，判断startFuel和target的关系</span></span><br><span class="line">        <span class="keyword">if</span>(stations.empty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> startFuel &gt;= target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startFuel &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; stations.size() &amp;&amp; stations[i][<span class="number">0</span>] &lt;= startFuel) &#123;</span><br><span class="line">                pq.push(stations[i][<span class="number">1</span>]);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pq.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            startFuel += pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>458. Poor Pigs</title>
      <link href="/2019/06/02/458.%20Poor%20Pigs/"/>
      <url>/2019/06/02/458.%20Poor%20Pigs/</url>
      
        <content type="html"><![CDATA[<h2 id="458-Poor-Pigs"><a href="#458-Poor-Pigs" class="headerlink" title="458. Poor Pigs"></a>458. Poor Pigs</h2><h3 id="description"><a href="#description" class="headerlink" title="description:"></a>description:</h3><p>There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour?<br>Answer this question, and write an algorithm for the general case.</p><h3 id="General-case"><a href="#General-case" class="headerlink" title="General case:"></a>General case:</h3><p>If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous bucket within p minutes? There is exactly one bucket with poison.</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><p>A pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time.<br>After a pig has instantly finished drinking buckets, there has to be a cool down time of m minutes. During this time, only observation is allowed and no feedings at all.<br>Any given bucket can be sampled an infinite number of times (by an unlimited number of pigs).</p><p>输入：int buckets, int minutesToDie, int minutesToTest</p><p>输出：pig的数量</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题用了信息论的知识</p><p>minutesToTest 是可以测试的时间</p><p>minutesToDie 是测试一次需要的时间</p><p>所以t = minutesToTest/minutesToDie 就是一共可以测试的次数</p><p>我们可以反向理解，给定n个小猪，给定t次测试次数，求最多可以有几个水桶。</p><p>当有2个小猪，1个测试次数时<br>可以有4个水桶，分析如下</p><table><thead><tr><th>水桶</th><th align="center">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td>喝水情况</td><td align="center">00</td><td align="right">01</td><td align="right">10</td><td align="right">11</td></tr></tbody></table><p>其中00代表小猪1,2都不喝水桶1的水；01代表小猪1不喝水桶1的水，小猪2在第一轮喝水桶1的水。</p><p>当有2个小猪，2个测试次数时（即两轮）,可以有9个水桶：</p><table><thead><tr><th>水桶</th><th align="center">1</th><th align="right">2</th><th align="right">3</th><th align="right">4</th><th align="center">5</th><th align="right">6</th><th align="right">7</th><th align="right">8</th><th align="right">9</th></tr></thead><tbody><tr><td>喝水情况</td><td align="center">00</td><td align="right">01</td><td align="right">02</td><td align="right">10</td><td align="center">11</td><td align="right">12</td><td align="right">20</td><td align="right">21</td><td align="right">22</td></tr></tbody></table><p>其中00代表小猪1,2都不喝水桶1的水；01代表小猪1不喝水桶1的水，小猪2在第一轮喝水桶1的水；21表示小猪1在第二轮喝水桶8的水，小猪2在第一轮喝水桶8的水。</p><p>假设5号水桶有毒，则小猪1,2在第一轮全部死亡，只有5号水桶可以做到这一点。<br>假设6号水桶有毒，则小猪1在第一轮结束后死亡，可以确定水桶4,5,6有问题，又根据小猪2在第一轮结束后存活，可以确定水桶6有问题。<br>所以根据小猪喝水后死亡的情况，就可以唯一确定一个水桶是有毒的。<br>所以总结：</p><p>可以有的最大水桶数为：（t + 1）<sup>n</sup>个</p><p>反之 需要的小猪数量为log<sub>(t + 1)</sub><sup>buckets</sup>个</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123;</span><br><span class="line">        int pig = 0;</span><br><span class="line">        int base = ceil(minutesToTest / minutesToDie) + 1;</span><br><span class="line">        while (pow(base, pig) &lt; buckets) pig ++;</span><br><span class="line">        return pig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>440. K-th Smallest in Lexicographical Order</title>
      <link href="/2019/06/02/440.%20K-th%20Smallest%20in%20Lexicographical%20Order/"/>
      <url>/2019/06/02/440.%20K-th%20Smallest%20in%20Lexicographical%20Order/</url>
      
        <content type="html"><![CDATA[<h2 id="440-K-th-Smallest-in-Lexicographical-Order"><a href="#440-K-th-Smallest-in-Lexicographical-Order" class="headerlink" title="440. K-th Smallest in Lexicographical Order"></a>440. K-th Smallest in Lexicographical Order</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.</p><p>Note: 1 ≤ k ≤ n ≤ 109.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><pre><code>Input:n: 13   k: 2Output:10Explanation:The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题一上来可能没思路，仔细想一下发现lexicographical order可以转化为树的先序遍历来做。<br>具体转化过程如下:</p><p><img src="https://user-images.githubusercontent.com/20705797/58773132-7e594100-85ee-11e9-8145-e5330c72c970.jpg" alt="树结构"></p><p>求第k小的数即是求树的先序遍历的第k个节点的值，我们可以直接构建一个树，但是这样太麻烦。</p><p>我们的目标是从第1个节点开始，移动<strong>k - 1</strong> 步到目标节点。</p><p>为了减少移动次数，我们先计算同一level的邻居节点之间的步数以跳过不必要的先序遍历。<br>比如说假设<strong>n</strong>为20，<strong>k</strong>为12，我们一开始处于节点1，我们先计算节点1和2之间的步数（1和2之间有11步），然后令<strong>k = k - 11</strong>就可以直接跳到节点2，此时k为1，输出节点2的值。</p><p>所以总体思路是：假设我们处于<strong>cur</strong>节点上，我们先计算同一level的邻居节点之间的步数<strong>steps</strong>，如果<strong>steps</strong>小于<strong>k</strong>，我们跳到邻居节点<strong>cur + 1</strong>，然后令<strong>k -= steps</strong>,当steps大于等于k时，我们进入树的下一层，然后用同样的方法计算，最终到达目标节点。</p><p>那么我们如何计算节点之间的步数呢，假设第一个节点是<strong>now</strong>，邻居节点是<strong>next</strong>,当<strong>next &lt;= n</strong>时，我们就把同一level从<strong>now</strong> 到<strong>next</strong>之间的节点数量加上来，如果 <strong>next &gt; n</strong>，我们就把<strong>now</strong>到<strong>n</strong>（包括<strong>n</strong>）之间的节点数量加上来，然后进入树的下一层重复刚刚的操作。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cur = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> steps = calcSteps(cur, cur + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span> (steps &lt; k) &#123;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">                k -= steps;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">                cur *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calcSteps</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">long</span> next, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (now &lt;= n) &#123;</span><br><span class="line"></span><br><span class="line">            steps += min(n + <span class="number">1</span>, next) - now;</span><br><span class="line">            next *= <span class="number">10</span>;</span><br><span class="line">            now *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 300. Longest Increasing Subsequence 最长上升子序列</title>
      <link href="/2019/06/02/394.%20Decode%20String/"/>
      <url>/2019/06/02/394.%20Decode%20String/</url>
      
        <content type="html"><![CDATA[<h2 id="394-Decode-String"><a href="#394-Decode-String" class="headerlink" title="394. Decode String"></a>394. Decode String</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an encoded string, return it’s decoded string.</p><p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题的思路是从字符串的开头往后面读，当读到数字的时候，就把数字存起来，当读到字符串的时候，把字符串存起来，然后把<strong>数字 * 字符串</strong> 个数的字符存到最终字符串里面。</p><p>当遇到<strong>[</strong> 的时候，就进行递归，把上面的步骤再执行一遍，遇到 <strong>]</strong>时结束递归，返回递归内得到的字符串，然后把递归内得到的字符串拼接到最终字符串里面。</p><p>具体代码如下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> previousIsDigit = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> finalstr = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> localstr = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; index &lt; s.size(); index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[index] == <span class="string">']'</span>)</span><br><span class="line">                <span class="keyword">return</span> finalstr;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[index])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!previousIsDigit)</span><br><span class="line">                    digit = s[index] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    digit = digit * <span class="number">10</span> + (s[index] - <span class="string">'0'</span>);</span><br><span class="line">                previousIsDigit = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s[index] == <span class="string">'['</span>)) &#123;</span><br><span class="line">                previousIsDigit = <span class="literal">false</span>;</span><br><span class="line">                index ++;</span><br><span class="line">                <span class="built_in">string</span> str = decodeString(s);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; digit; j++) &#123;</span><br><span class="line">                    finalstr += str;</span><br><span class="line">                &#125;</span><br><span class="line">                digit = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; s.size() &amp;&amp; s[index] != <span class="string">']'</span>) </span><br><span class="line">                    index++;       </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                previousIsDigit = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">isalpha</span>(s[index]) &amp;&amp; index &lt; s.size()) &#123;</span><br><span class="line">                    localstr += s[index];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; digit; j++) &#123;</span><br><span class="line">                    finalstr += localstr;</span><br><span class="line">                &#125;</span><br><span class="line">                digit = <span class="number">1</span>;</span><br><span class="line">                localstr = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> finalstr; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 354. Russian Doll Envelopes 俄罗斯套娃信封问题</title>
      <link href="/2019/06/02/354.%20Russian%20Doll%20Envelopes/"/>
      <url>/2019/06/02/354.%20Russian%20Doll%20Envelopes/</url>
      
        <content type="html"><![CDATA[<h2 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a>354. Russian Doll Envelopes</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p><p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p><p>Note:<br>Rotation is not allowed.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Input: [[5,4],[6,4],[6,7],[2,3]]Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>遇见这种题一上来应该先排一下序，先按照套娃的宽度从小到大排序，如果宽度相同就按照高度从小到大排序。</p><p>这样就可以用DP的方法来求解了，DP数组中值最大的就是解（<strong>解法1</strong>）。</p><p>但是这道题还有一道更巧妙的解法：先按照套娃的宽度从小到大排序，如果宽度相同就按照高度从大到小排序。</p><p>然后这道题就转换称为高度的最长上升子序列问题（<a href="https://blog.csdn.net/qq_31027515/article/details/90719559" target="_blank" rel="noopener">点击查看详解</a>），最长上升子序列的长度就是解（<strong>解法2</strong>）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> n = envelopes.size();</span><br><span class="line">        sort(envelopes.begin(), envelopes.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                <span class="keyword">if</span> (envelopes[j].first &lt; envelopes[i].first &amp;&amp; envelopes[j].second &lt; envelopes[i].second)</span><br><span class="line">                    dp[i]  = max(dp[i] , dp[j] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> n = envelopes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  </span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : envelopes) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(res.begin(), res.end(), v.second);</span><br><span class="line">            <span class="keyword">if</span> (iter == res.end()) </span><br><span class="line">                res.push_back(v.second);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *iter = v.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 动人规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 300. Longest Increasing Subsequence 最长上升子序列</title>
      <link href="/2019/06/02/300.%20Longest%20Increasing%20Subsequence/"/>
      <url>/2019/06/02/300.%20Longest%20Increasing%20Subsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.    </p><p>Note:</p><p>There may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题是典型的dp问题，我们先创建一个<em>dp</em>数组，其中<em>dp[i]</em>表示到i为止最长上升子序列,则<em>dp[i]=max(dp[j])+1 0 &lt;= j &lt; i</em>。</p><p>遍历<em>i</em>从<strong>1</strong>到<strong>n-1</strong>，<em>j</em>从<strong>0</strong>到<strong>i - 1</strong>即可得到dp数组，dp数组中最大的值就为解（解法1）。</p><p>另一种思路是，我们也先创建一个dp数组，这个数组保存目前最长的最长上升子序列。</p><p>当遍历数组nums的时候，我们尝试向这个dp数组中用二分法查找并插入当前元素（每次插入都保证这个数组是排好序的）。</p><p>当<em>dp</em>数组中最大值小于<em>nums[i]</em>, 我们就像<em>dp</em>数组尾部加入<em>nums[i]</em>。否则就令<em>dp</em>数组中刚好大于<em>nums[i]</em>的这个值用<em>nums[i]</em>替换掉，最后<em>dp</em>数组的长度就是最长上升子序列（解法2）。</p><p>在解法2中，若插入在<em>dp</em>数组的尾部，最长上升子序列的长度加<strong>1</strong>，若替换掉<em>dp</em>数组中的某个值，不改变已有的最长上升子序列的长度，所以解法2是正确的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(n, <span class="number">1</span>);</span><br><span class="line">        Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        vec[i] = max(vec[i], vec[j] + <span class="number">1</span>);</span><br><span class="line">        Max = max(Max, vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(res.begin(), res.end(), nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it==res.end()) res.push_back(nums[i]);</span><br><span class="line">        <span class="keyword">else</span> *it = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.size();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 动人规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2019/06/02/15.%203Sum/"/>
      <url>/2019/06/02/15.%203Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题如果上来直接暴力破解的话，时间复杂度为O($n^3$)。</p><p>一个想法是，先把数组排序一遍（O($nlogn$)），然后固定第一个数，其他两个数用两个指针（two pointer）的方法来做，总时间复杂度为O($n^2$)。</p><p>注意这道题要求不能有重复的值，所以每找到一组解，我们要确保这组解之前没有出现过。</p><p>假设三个数的下标是 <strong>i</strong>, <strong>j</strong>, <strong>k</strong></p><p>因为数组是排好序了，所以在找到一组解之后，我们令<strong>j++</strong>， <strong>k–</strong> 直到<strong>j</strong>, <strong>k</strong>的值和之前不同。</p><p>最后别忘了要保证<strong>i</strong>的值和上一次循环不同。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">auto</span> target = - nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] + nums[k] == target) &#123;</span><br><span class="line"></span><br><span class="line">        res.push_back(&#123;nums[i], nums[j], nums[k]&#125;); </span><br><span class="line">        <span class="keyword">while</span>(j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; j &amp;&amp; nums[k] == nums[k - <span class="number">1</span>] ) k--;</span><br><span class="line">        j++;</span><br><span class="line">        k--;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] + nums[k] &lt; target) &#123;       </span><br><span class="line">        j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;        </span><br><span class="line">        k--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">while</span> (i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 两指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2019/06/02/11.%20Container%20With%20Most%20Water/"/>
      <url>/2019/06/02/11.%20Container%20With%20Most%20Water/</url>
      
        <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><p><img src="https://user-images.githubusercontent.com/20705797/58773142-8ca75d00-85ee-11e9-8cc6-01d7c5d0cc16.jpg" alt="question_11"></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题最简单的解法是用暴力破解，即遍历每对可能的边，计算可以容纳水的体积，但是这样的复杂度为O($n^2$)。</p><p>一种更简单的方法使用两个指针的方法，一个指针指向数组的头部，另一个指向数组的尾部，计算两条边之间可以容纳水的体积，然后比较头指针指向的边和尾指针指向的边的长度，如果头指针指向的边长，就令尾指针 <strong>-1</strong> ，否则头指针 <strong>+1</strong>。</p><p>在这个过程中，我们定义一个变量MostWater，实施更新可以容纳的最大体积。<br>时间复杂度为O($n$)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> MostWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        MostWater = max(MostWater, (hi - lo) * min(height[lo], height[hi]));</span><br><span class="line">        <span class="keyword">if</span> (height[lo] &gt; height[hi])</span><br><span class="line">        hi --;</span><br><span class="line">        <span class="keyword">else</span> lo ++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MostWater;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 两指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2019/06/02/4.%20Median%20of%20Two%20Sorted%20Arrays/"/>
      <url>/2019/06/02/4.%20Median%20of%20Two%20Sorted%20Arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h2><h3 id="description"><a href="#description" class="headerlink" title="description:"></a>description:</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><pre><code>nums1 = [1, 3]nums2 = [2]The median is 2.0</code></pre><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><pre><code>nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>中位数是整个序列从小到大排列，位置处于最终间的数。</p><p>本道题是求两个已经排好序的数组的中位数</p><p>假设一个数组为<strong>A</strong>，另一个数组为<strong>B</strong></p><p>那么中位数把数组<strong>A</strong>，<strong>B</strong>的左边和右边分为两块，让左边的大小和右边的大小相等。</p><p>如下图所示。</p><table><thead><tr><th>左边</th><th align="center">右边</th></tr></thead><tbody><tr><td><strong>A[0], A[1], …, A[i-1]</strong></td><td align="center"><strong>A[i], A[i+1], …, A[m-1]</strong></td></tr><tr><td><strong>B[0], B[1], …, B[j-1]</strong></td><td align="center"><strong>B[j], B[j+1], …, B[n-1]</strong></td></tr></tbody></table><p>其中<strong>A[i-1]</strong> 小于 <strong>A[i]</strong>（已知），<strong>B[j-1]</strong> 小于 <strong>B[j]</strong>（已知）， <strong>A[i-1]</strong>小于<strong>B[j]</strong>，<strong>B[j-1]</strong>小于<strong>A[i]</strong></p><p>假设数组A的长度为<strong>m</strong>，数组B的长度为<strong>n</strong> ,<strong>m</strong>的左边有<strong>i</strong>个，<strong>n</strong>的左边有<strong>j</strong>个，则<strong>i + j = m - i + n - j + 1</strong>，所以j = $\frac{m + n + 1}{2} - i$</p><p>为了保证<strong>j &gt; 0</strong>，我们需要保证$\frac{m + n + 1}{2} - i$，所以我们需要保证<strong>m</strong>小于<strong>n</strong>。</p><p>所以本算法的精髓就是通过对<strong>i</strong>进行二分查找来找到一个<strong>i</strong>，满足 <strong>A[i-1]</strong> 小于 <strong>B[j]</strong> ，<strong>B[j-1]</strong> 小于 <strong>A[i]</strong> 时，即可以把两个数组划分为等长的两部分，即可以找到中位数。</p><p>当找到的<strong>i</strong>使得 <strong>A[i - 1]</strong>  &gt; <strong>B[j]</strong> 时，说明i过大，我们应该在i的左边进行二分查找。</p><p>当找到的<strong>i</strong>使得<strong>A[i]</strong> &lt;  <strong>B[j - 1]</strong> 时，说明i过小，我们应该在i的右边进行二分查找。</p><p>这里需要注意，当<strong>i</strong>等于<strong>0</strong>的时候 <strong>A[i - 1]</strong> 不存在，当 <strong>i = m</strong> 时 <strong>A[i]</strong> 不存在，j也是如此，所以我们需要对这些边界条件进行特殊处理。</p><p>最后根据<strong>m + n</strong>的奇偶性进行返回，当<strong>m + n</strong>为奇数时，返回左边的最大值，当<strong>m + n</strong>为偶数时，返回$\frac{左边的最大值+右边的最大值}{2}$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1.size() &gt; nums2.size() ) </span><br><span class="line">    <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">    <span class="keyword">auto</span> m = nums1.size();</span><br><span class="line">    <span class="keyword">auto</span> n = nums2.size();</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = m, halfLen = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = halfLen - i;</span><br><span class="line">    <span class="comment">//当i等于m时，j可能为0，nums2[j - 1]不存在</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j - <span class="number">1</span>] )</span><br><span class="line">    lo = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//当i等于0时，nums1[i - 1]不存在</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>  &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j])</span><br><span class="line">    hi = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMin = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先求左边的最大值，如果m + n为奇数，则左边的最大值就是中位数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">    leftMax = nums2[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">    leftMax = nums1[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    leftMax = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> leftMax;</span><br><span class="line">    <span class="comment">//求右边的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">    rightMin = nums2[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">    rightMin = nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    rightMin = min(nums2[j], nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (leftMax + rightMin) / <span class="number">2.</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2019/06/02/1.%20Two%20Sum/"/>
      <url>/2019/06/02/1.%20Two%20Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题的暴力解法是用双重循环，遍历数组找到和为<strong>target</strong>的 两个数的下标，这样的复杂度为O($n^2$)。</p><p>我们还可以先把数组排序一遍，然后用两个指针（two pointer）的方法来做， 这个的时间复杂度为O($nlogn$)。</p><p>最快的一种算法是，先建立一个map，然后遍历数组，对于遇见的每一个数num，判断target - num 是否在这个map里面，则输出这两个数的下标，时间复杂度为O($n$)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (umap.find(target - nums[i]) == umap.end())</span><br><span class="line">    umap[nums[i]] = i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;umap[target - nums[i]], i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 两指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
